<?php

declare(strict_types=1);

namespace App\Pro\Entity\Product;

use App\Entity\BlameableEntity;
use App\Entity\CommonProperties;
use App\Pro\Entity\Order;
use App\Pro\Enum\RecurringInterval;
use App\Pro\Repository\Product\PriceRepository;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Mapping as ORM;
use Gedmo\Timestampable\Traits\TimestampableEntity;
use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Component\Validator\Context\ExecutionContextInterface;
use Twig\Extra\Intl\IntlExtension;

#[ORM\Entity(repositoryClass: PriceRepository::class)]
class Price
{
    use BlameableEntity;
    use CommonProperties\Description;
    use CommonProperties\Required\AutoGeneratedId;
    use CommonProperties\Required\Enabled;
    use Stripe\Price;
    use TimestampableEntity;

    #[Assert\GreaterThanOrEqual(0)]
    #[ORM\Column]
    private ?float $unitAmount = null;

    #[Assert\Currency]
    #[ORM\Column(length: 3)]
    private ?string $currency = null;

    #[ORM\Column(nullable: true, enumType: RecurringInterval::class)]
    private ?RecurringInterval $recurringInterval = null;

    #[Assert\GreaterThanOrEqual(1)]
    #[ORM\Column(nullable: true)]
    private ?int $recurringIntervalCount = null;

    #[Assert\GreaterThanOrEqual(0)]
    #[ORM\Column(nullable: true)]
    private ?int $recurringTrialPeriodDays = null;

    #[ORM\ManyToOne(inversedBy: 'prices')]
    #[ORM\JoinColumn(nullable: false, onDelete: 'CASCADE')]
    private ?Product $product = null;

    /**
     * @var Collection<int, Order>
     */
    #[ORM\OneToMany(targetEntity: Order::class, mappedBy: 'price')]
    private Collection $orders;

    public function __construct()
    {
        $this->orders = new ArrayCollection();
    }

    public function __toString(): string
    {
        return ($this->isEnabled() ? '✅' : '❌').' '
            .$this->formatAmount()
            .$this->formatRecurring()
            .$this->formatTrial()
        ;
    }

    public function formatAmount(): string
    {
        return (new IntlExtension())->formatCurrency($this->getUnitAmount(), $this->getCurrency());
    }

    public function formatRecurring(): string
    {
        return $this->isRecurring() ?
            (' / '.$this->getRecurringIntervalCount().' '
                .strtolower($this->getRecurringInterval()->value)
                .(1 < $this->getRecurringIntervalCount() ? 's' : ''))
            : '';
    }

    public function formatTrial(): string
    {
        return $this->getRecurringTrialPeriodDays() ? ' ('.$this->getRecurringTrialPeriodDays().' days trial)' : '';
    }

    public function getUnitAmount(): ?float
    {
        return $this->unitAmount;
    }

    public function setUnitAmount(float $unitAmount): static
    {
        $this->unitAmount = $unitAmount;

        return $this;
    }

    public function getCurrency(): ?string
    {
        return $this->currency;
    }

    public function setCurrency(string $currency): static
    {
        $this->currency = $currency;

        return $this;
    }

    public function isRecurring(): bool
    {
        return null !== $this->getRecurringInterval() && 0 < $this->getRecurringIntervalCount();
    }

    public function getRecurringInterval(): ?RecurringInterval
    {
        return $this->recurringInterval;
    }

    public function setRecurringInterval(?RecurringInterval $recurringInterval): static
    {
        $this->recurringInterval = $recurringInterval;

        return $this;
    }

    public function getRecurringIntervalCount(): ?int
    {
        return $this->recurringIntervalCount;
    }

    public function setRecurringIntervalCount(?int $recurringIntervalCount): static
    {
        $this->recurringIntervalCount = $recurringIntervalCount;

        return $this;
    }

    public function getRecurringTrialPeriodDays(): ?int
    {
        return $this->recurringTrialPeriodDays;
    }

    public function setRecurringTrialPeriodDays(?int $recurringTrialPeriodDays): static
    {
        $this->recurringTrialPeriodDays = $recurringTrialPeriodDays;

        return $this;
    }

    public function getProduct(): ?Product
    {
        return $this->product;
    }

    public function setProduct(?Product $product): static
    {
        $this->product = $product;

        return $this;
    }

    /**
     * @return Collection<int, Order>
     */
    public function getOrders(): Collection
    {
        return $this->orders;
    }

    public function addOrder(Order $order): static
    {
        if (!$this->orders->contains($order)) {
            $this->orders->add($order);
            $order->setPrice($this);
        }

        return $this;
    }

    public function removeOrder(Order $order): static
    {
        if ($this->orders->removeElement($order)) {
            // set the owning side to null (unless already changed)
            if ($order->getPrice() === $this) {
                $order->setPrice(null);
            }
        }

        return $this;
    }

    #[Assert\Callback()]
    public function validateRecurringFields(ExecutionContextInterface $context): void
    {
        $fields = [
            $this->getRecurringInterval(),
            $this->getRecurringIntervalCount(),
            $this->getRecurringTrialPeriodDays(),
        ];

        $filledCount = \count(array_filter($fields, static fn ($value) => null !== $value));

        if ($filledCount > 0 && $filledCount < 3) {
            $context->buildViolation('All recurring fields must be set together or left empty.')
                ->atPath('recurringInterval')
                ->addViolation();
        }
    }
}
